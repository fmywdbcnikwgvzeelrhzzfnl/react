Lesson 2
    1. Выполнить глобальное подключение webpack и необходимых загрузчиков.
    2. Разработать структуру проекта. Продумать, какие компоненты будут входить в состав каждого js-элемента. Разработать компонент, выводящий ФИО разработчика.
    3. Необходимо изменить один из файлов таким образом, чтобы в нем подключался новый компонент и выводился на главной странице.
    4. *Для нового компонента необходимо прописать класс.
    5. *Выполнить событие Клик (onClick). При клике на компонент должна выводиться текущая дата.
    Задачи со * – повышенной сложности.

Lesson 3
    1. Реализовать шаблон главной страницы блога. Реализовать это необходимо в стиле react, то есть на выходе у вас должен быть компонент Layout, который задает структуру страниц: главная страница (например, MainPage), на которой будет отображаться наша заглушка со статьями, а также элементы menu и login.
    На странице должны присутствовать следующие элементы:
    a. Меню навигации;
    b. Кнопка для логина;
    c. Место для контента страницы;
    d. *(Опционально) Боковое/нижнее меню;
    e. *Используя bootstrap, реализуйте поведение для нажатия на кнопку login, а именно: при нажатии на кнопку login должно показываться модальное окно, где можно ввести логин и пароль для авторизации на сайте. При этом можно использовать как react-bootstrap пакет, так и чистый bootstrap.

Lesson 4
    Выполнить страницу с компонентами:

    1. Просмотреть ссылки с примерами реализации:
    https://getbootstrap.com/examples/blog/
    https://blackrockdigital.github.io/startbootstrap-clean-blog/
    https://blackrockdigital.github.io/startbootstrap-blog-post/
    https://blackrockdigital.github.io/startbootstrap-blog-home/

    2. Декомпозировать (разбить) страницу на наборы компонентов.
    3. Для каждого из полученных компонентов написать стили и описать состояние и его изменение. Предусмотреть взаимодействие между компонентами.
    4. *Из полученных компонентов сделать страницу.
    5. *Для компонента страницы предусмотрите такое поведение, чтобы при входе на страницу выводилось модальное окно с приветствием (можно выполнить посредством alert.~)

Lesson 5
    Для приложения необходимо выполнить следующее:

    1. Реализовать страницы: Главная, Блог, Комментарии, Пользователи.
    2. Для упрощения процесса разработки можете сделать так же, как мы делали на занятии, реализовав Layout компонент (у нас он называется Default), где будет описан шаблон страниц.
    3. *На всех страницах должно присутствовать навигационное меню, которое будет выделять текущее местоположение подсветкой элемента меню.

    Для Главной страницы можно написать либо текст-пустышку (lorem ipsum), либо общие сведения о проекте.

    Для Блога:
    1. Необходимо выводить каждый блог отдельным элементом (стилизационные вопросы – на ваше усмотрение).
    2. *При клике на этом блоге должен происходить переход на страницу с деталями, где будут отображаться записи блога, а так же пользователь – владелец блога.

    Для страницы Комментарии:
    1. Выводить список последних комментариев, добавленных в наш блог.
    2. Для каждого выведенного сообщения должна быть доступна ссылка на сам блог.

    Для страницы Пользователи:
    1. Выводить пользователей приложения.
    2. *При клике на пользовате должна отображаться информация о блогах пользователя и его последних комментариях (это все может отсутствовать).
    Все данные можно либо придумать и, например, разместить в json-файлах, либо скачивать из Интернета. Для более грамотной разработки следует все эти вещи помещать в отдельную сущность – например, UserService или BlogService – которые будут заниматься своими данными, их отдачей, поиском и т.д.

Lesson 6
    1. Создать хранилище (store), где будут находить все записи нашего блога. При этом,
    для всех записей блога должна быть возможность: создать, удалить, отредактировать эти
    блоги.
    2. Для каждого метода хранилища, который является методом действия, необходимо
    создать соответствующий Action либо в виде функции, либо в виде класса. В итоге должен
    получиться файл, который либо экспортирует набор функций, либо целый класс.
    3. Для всех видов действий необходимо создать соответствующие константы, которые
    будут описывать то действие, которое будет совершаться. Опять же, необходимо положить их
    в отдельный файл.
    4. Последним шагом необходимо в конечном компоненте импортировать хранилище и
    действия и прописать их использование в необходимых местах.
    5. *При этом также следует создать обратную связь между изменением состояния в
    хранилище и актуальным состоянием в компоненте (мы это делали через EventEmitter).
    6. * Реализовать это же задание с применением Redux библиотеки.

Lesson 7
    1. Для сохранения состояния реализовать хранилище (store), которое представляет собой комбинацию редьюсеров (reducers), объединенных методом combineReducers. Магазин создается при помощи функции createStore(reducer, state, middleware) (см. проект с урока).
    2. Чтобы разделить ответственность по обработке частей состояния, необходимо для каждой части создать свой редьюсер. Каждый редьюсер – это функция, которая принимает 2 аргумента: state и action (где state – текущее состояние, которое требуется изменить, а action – действие, которое диктует правила изменения этого состояния). Результат работы функции редьюсера – новое состояние, которое эта функция и возвращает. Не забывайте главное правило – состояние иммутабельно, поэтому мы должны всегда порождать новое состояния на основании старого. При этом необходимо производить клонирование тех элементов, которые являются ссылочными. Например, массивы: обычно для них хватает вызова функции slice(0). Эти редьюсеры должны быть скомбинированы при создании магазина в один редьюсер. Также необходимо в редьюсре задать для состояния начальный вид, так как изначально state – undefined.
    3. Для всех требуемых действий создать соответствующие функции – actions, которые возвращают либо объект, который будет передан диспетчеру, либо функцию (в случае асинхронной обработки), которая принимает входной параметр dispatch (функция для асинхронной диспетчеризации).
    4. Для увязки нашего приложения с состоянием хранилища необходимо на главной странице, где отрисовывается основной элемент приложения, обернуть все роуты в элемент Provider и задать его свойство store = { сюда мы помещаем экземпляр нашего хранилища из п. 2 }
    5. При работе с компонентами приложения, которые будут изменять состояние или обращаться к нему, мы должны использовать функцию connect из react-redux пакета. Эта функция накладывается на компонент в качестве декоратора (аля @connect()). Первым и самым важным ее параметром является функция, которая принимает наше хранилище (store) и должна вернуть объект. Этот объект, а точнее его свойства, будут записаны в this.props нашего компонента. В том числе в this.props.dispatch будет записана функция диспетчеризации. Вся работа по изменению состояния ведется через нее и вызовы соответствующих действий, которые порождают требуемый для диспетчеризации объект (или функцию). Более подробная информация – по ссылкам.
    6. Если нужно, можно сделать свои middleware и подключить их в процесс обработки изменения состояния.